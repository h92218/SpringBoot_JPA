@Entity
JPA Entity

@Id
식별자

@GeneratedValue
PK값을 JPA가 순차적인 값을 자동 생성


@PersistenceContext
스프링 컨테이너가 영속성 컨텍스트 생성(EntityManager)


@SpringBootTest
junit5에서는 @RunWith(SpringRunner.class)이게 없어도 된다~


@Test
org.junit.jupiter.api.Test

* NoArgsConstructor(access = AccessLevel.PROTECTED)
protected 기본생성자
JPA Entity는 protected 기본생성자가 있어야댐
JPA는 프록시기술을 쓰기 때문에 private으로 막아놓으면 안 됨.


@Transactional
클래스레벨에 달아줌.
JPA의 모든 변경은 트랜잭셕 안에서 이루어져야 함
테스트 끝날 때 롤백을 시켜줌.
롤백을 안 하려면 @Rollback(false) => 커밋이 되고 DB에 반영이 된다.
같은 트랜잭션 안에서는 동일성이 보장됨.
트랜잭션이 다르면 다른 객체가 조회가 된다.


* 스프링 데이터 JPA는
org.springfamework.data.jpa.repository.JpaRepository
Repository는 Interface로 생성했음. 
JpaRepository(인터페이스)를 상속받는다.


@ManyToOne(fetch = FetchType.LAZY)
다대일 관계,
@JoinColumn(name="team_id") 으로 외래키 이름을 써 준다.
연관관계의 주인(두 객체 중 하나의 객체만 테이블을 관리할 수 있는 쪽)이 되는 쪽은 1:N 중에 N쪽임.
연관관계의 주인만이 외래키를 관리할 수 있다.
mappedBy 쪽은 읽기만 가능
모든 연관관계는 지연로딩해야함(fetch = FetchType.LAZY)
지연로딩 설정이 되어있는 엔티티는 프록시 객체로 가져오며
후에 실제 객체를 사용하는 시점에 초기화가 되어 DB 쿼리를 실행한다.
즉시로딩(EAGER)인 경우 N쪽 객체를 조회하는 시점에 1쪽 객체까지 불러오는 쿼리를 날린다.
즉시 로딩은 항상 외부조인을 사용한다.
fetch의 디폴트 값 : @xxToOne은 EAGER, @xxToMany는 LAZY



@OneToMany(mappedBy ="team")
일대다 관계.
mappedBy는 연관관계의 주인이 아닌 것을 표시하는 설정
값은 반대쪽 객체에 자신이 맵핑되어 있는 필드명


* flush,clear
flush : 영속성 컨텍스트에서 강제로 DB insert
clear : 영속성 컨텍스트에서 캐시 비우기

