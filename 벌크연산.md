## 벌크연산
여러 update, delete 연산을 하나의 쿼리로 하는 것.

```java
@Transactional
@Override
public void bulkUpdateTest(){
    LocalDateTime now = LocalDateTime.now();
    queryFactory.update(qGoods)
            .set(qGoods.created,now)
            .execute();
        
    em.flush();
    em.clear();
}
```

## custom 구현체에는 @Transactional 어노테이션이 없으므로
벌크연산 메소드에 @Transactional 붙여줄것   
안붙이면 TransactionRequiredException: Executing an update/delete query 에러가 남   

## em.flush() 와 em.clear()를 붙이는 이유 
영속성 컨텍스트(1차 캐시)에 들어있는 엔티티와 DB의 데이터 간에 싱크가 안 맞는 걸 방지하기 위함.   
```java
public void bulkUpdateTest() throws DServiceException{
    Goods goods = goodsRepository.findByIdx(21L);
    System.out.println("bulk 수정 전 created :: " + goods.getCreated());
    goodsRepository.bulkUpdateTest();
    Goods goods2 = goodsRepository.findByIdx(21L);
    System.out.println("bulk 수정 후 created :: " + goods2.getCreated());
} //붙이지 않으면 연산 수정 후 조회한 값은 DB가 아니라 1차 캐시에서 가져온다.
```

##  조회를 쿼리메소드가 아니라 queryDSL 쿼리로 하면? 
=> queryDSL로 하는 경우에도 같음.

## clear 안 했을 때 첫번째 조회, 두번째 조회 모두 query가 나가는 이유 
영속성 컨텍스트에 값이 존재하면 DB조회 안하는거 아닌가?    
=> JPA는 쿼리메소드의 이름을 분석해서 JPQL을 생성하고 실행한다.   
=> JPQL ?   
- 항상 데이터베이스를 조회한다.   
- JPQL로 조회한 엔티티는 영속 상태다.   
- 영속성 컨텍스트에 해당 엔티티가 이미 존재하면 기존 엔티티를 반환한다.   
